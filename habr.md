# "Оптимизируем" функции на уровне AST

Python предоставляет программисту огромное пространство свободы. Увы, обычно это довольно дорогая в плане производительности свобода, зато при правильном применении иногда она позволяет творить сущую магию. Но сегодня мы поговорим не о таких вот, "богоугодных", применениях свободы, а о том, что в прикладном программировании не стоит использовать никогда - о модификациях кода на уровне AST.

## Да кто такой этот ваш AST?

Обычно принято говорить, что [CPython](https://en.wikipedia.org/wiki/CPython) выполняет код построчно. Это не совсем правда, и прежде, чем идти дальше, я должен сделать небольшую паузу, чтобы кратко описать схему его работы.

Прежде всего, любой код - это последовательность символов в некоем файле (в случае [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) - введенная в консоли). Как бы по-программистски эта последовательность ни выглядела, она не является программой, то есть не может быть выполнена компьютером, пока с ней не будет проделан ряд [шагов](https://habr.com/ru/company/otus/blog/442252/).

Первый шаг - [парсинг текста](https://en.wikipedia.org/wiki/Parsing). Если мы представим парсер как функцию, то на вход она должна получать "сырой" текст, а на выходе давать уже последовательность неких "токенов", то есть значащих элементов нашей программы. Токенами могут быть различные "захардкоженные" (for, if, True и т. д.) ключевые слова программы, имена сущностей (переменных, функций, классов), строковые литералы и прочее. Парсинг происходит по некоторому набору правил, называемому [абстрактной грамматикой](https://docs.python.org/3.2/library/ast.html#abstract-grammar). Конкретно в случае CPython мы не имеем возможности, к сожалению, как-то влезть в процесс парсинга, добавив таким образом, скажем, новый набор ключевых слов.

Второй шаг - построение на основе полученных из предыдущего шага токенов синтаксического дерева (или, как его принято называть у нас в деревне - [AST](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)). AST - это, как очевидно по названию, некая [древовидная](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2)) структура данных, где каждая нода получена из какого-нибудь токена, который мы извлекли на этапе парсинга. Эта нода может быть терминальной, либо содержащей ссылки на нижележащие ноды. Скажем, нода, представляющая блок условия, может содержать в себе список нод, описывающих действия программы в случае, когда это условие выполняется. Ноды в AST являются типизированными, то есть они имеют разный набор свойств, когда представляют разные виды токенов.

Третий шаг - генерация на основе AST графа потока управления ([Control Flow Graf](https://en.wikipedia.org/wiki/Control-flow_graph)). Очень грубо выражаясь, на этом шаге набор элементов исходного кода превращается в последовательность операций.

Четвертый и пятый шаги - компиляция графа в [байт-код](https://en.wikipedia.org/wiki/Bytecode) и его выполнение на [виртуальной машине](https://habr.com/ru/post/501338/). Тут наши полномочия все, код вступает в законную силу и изменению не подлежит (на самом деле подлежит, но надо упороться чуть [посильнее](https://docs.python.org/3/library/dis.html)).

Именно на втором шаге мы будем проводить свои "оптимизации" (я не случайно беру это слово в кавычки, но почему - раскрою позже). По сути они сводятся к трем типам возможных действий: добавление, удаление нод или модификация уже существующих (скажем, подмена одного строкового литерала другим). Работа с синтаксическим деревом является с одной стороны достаточно простым, с другой - очень мощным средством, позволяющим писать программы, которые буквально переписывают свой исходный код на лету (на самом деле нет, но выглядит это как будто бы так).

Что очень важно понимать про AST - оно "глупое". Оно не знает, что на самом деле лежит в ваших переменных - это определяется во время выполнения. По сути все, что оно из себя представляет - это некая чуть более упорядоченная форма бытия того самого текстового файлика, что вы подали на вход программы.

## Минздрав предупреждает

"не должен находиться у тебя [...] волшебник [...] ибо мерзок пред Господом всякий, делающий это, и за сии‐то мерзости Господь, Бог твой, изгоняет их от лица твоего" ([Второзаконие](https://bibleonline.ru/bible/rst66/deu-18/) 18:10-12)

Все эти наши штуки с AST интересные и вроде бы кажутся даже полезными, но не стоит поддаваться искушению применять такую магию в мире маглов. Здесь я опишу только общие соображения, почему это так, но дальше вы можете увидеть и другие проблемы с каждой из предложенных модификаций.

1. Фактически выполняться будет не тот код, что вы видите в файле с программой. У программистов пухнут головы уже от работы с тем кодом, что они видят, а тут, представьте, уже написанный код начинает себя вести не так, как выглядит.

2. Вы должны держать в голове нюансы реализации конкретной "оптимизации" и учитывать возможные побочные эффекты. Это вместо того, чтобы получше сосредоточиться на том, что должна делать ваша программа.

3. Средства интроспекции Python начинают врать. Допустим, мы добавили несколько нод в AST. Эти ноды не привязаны к конкретным строчкам исходного файла с кодом. А теперь вспомните, как выглядит, скажем, трейсбэк, когда в коде происходят исключения. Там подробно указывается, в какой строчке кода и с какой операцией произошла ошибка. Если эта ошибка случится в при выполнении кода из этих новых нод, трейсбек вас просто обманет.

4. Реальная выгода от большинства модификаций обычно крайне мала. Да, вам может показаться хорошей идеей применить такие модификации, как, скажем, раскрытие циклов или инлайнинг функций. Но увы, как показала практика, реальное ускорение кода при этом обычно находится на грани погрешности измерений. Если вам не хватает скорости в программах, написанных на Python, обычно самое лучшее решение - переписать их на чем-то еще.

## Общий воркфлоу

Итак, мы уже поняли, что хотим внедриться во второй этап работы интерпретатора и подсунуть ему модифицированное AST. Но не тут-то было, оказывается мы не можем сделать это напрямую. По факту мы для конкретного объекта функции вручную повторяем весь интерпретаторский воркфлоу, начиная с получения текста исходного кода, и заканчивая генерацией байт-кода.

Чтобы вам проще было ориентироваться в коде, здесь и далее мы всегда будем модифицировать функцию с именем 'kek', но ее содержимое будет меняться. Вот в общих чертах, что мы с ней делаем:

1. Получаем исходный код при помощи функции из модуля [inspect](https://docs.python.org/3/library/inspect.html#inspect.getsource).

```python
import ast, inspect


source = inspect.getsource(kek)
```

2. Заново парсим исходный код, получая на выходе то самое AST.

```python
tree = ast.parse(source)
```

Если вам любопытно, можете взглянуть, как выглядит дерево, запринтив его в консоль:

```python
print(ast.dump(tree, indent=4))
```

3. Что-то делаем с полученным AST. На выходе у нас должно получиться другое AST, которое мы обозначим как 'new_tree'. По сути это единственная часть в нашем уравнении, которая будет отличаться для разных модификаций, так что подробнее об этом будет далее.

4. Полученное AST скармливаем встроенной функции [```compile()```](https://docs.python.org/3/library/functions.html#compile), чтобы получить байт-код.

```python
bytecode = compile(new_tree, filename=inspect.getfile(kek), mode='exec')
```

5. Чтобы получить новый объект функции, байт-код с инициализацией функции 'kek' необходимо выполнить. Для этого используем встроенную функцию [```exec()```](https://docs.python.org/3/library/functions.html#exec).

```python
namespace = {}
exec(bytecode, namespace)
new_kek = namespace['kek']
```

Обратите внимание на переменную namespace. Если в определении функции kek фигурировали какие-то объекты, определенные в модуле, этими объектами нужно заполнить словарь пространства имен. Но в нашем упрощенном примере кода мы оставим его пустым.

Учитывайте, что, если в коде вашей функции встречается директива global, она будет привязана к тому "виртуальному" модулю, в котором происходило выполнение кода через функцию exec(). Изменяя через new_kek и через какую-то еще функцию какой-то глобальный объект, вы можете в обнаружить, что объекты, с которыми они работают - разные. В общем, не используйте global.

6. Если все пошло по плану, вы получили новый объект функции, с внесенными модификациями. Попробуйте выполнить его!

```python
new_kek('lol')
```

Что ж, пора приступить к модификациям.

## Простейшая модификация - выключатель для ифов

В пакете [ast](https://docs.python.org/3/library/ast.html) есть удобный инструмент для модификации узлов синтаксического дерева - класс [NodeTransformer](https://docs.python.org/3/library/ast.html#ast.NodeTransformer). У него есть метод, который запускает обход дерева. Каждую ноду при этом можно либо удалить, либо заменить на что-то другое. Для использования методов, мы должны отнаследоваться от NodeTransformer и переопределить там метод, модифицирующий конкретный тип нод - 'if'. Созданный под наши цели класс будет выглядеть так:

```python
systems = ('linux': True, 'windows': False)

class RewriteIfs(ast.NodeTransformer):
    def visit_If(self, node):
        try:
            variable_name = node.test.id
            if variable_name in systems:
                if not systems[variable_name]:
                    return None
                else:
                    return node.body
            return node
        except:
            return node
```

Запустим обход:

```python
new_tree = RewriteIfs().visit(tree)
```

После перекомпиляции мы получим функцию с измененным поведением. При обходе мы побывали во всех нодах условий, и если условие было унарным (то есть в нем присутствовал только один операнд), а также если имя переменной операнда фигурировало в словаре systems, с данным блоком if будет произведено одно из двух действий: 1. Если в словаре названию данного операнда соответствует False, весь блок будет уничтожен - для этого метод visit_If при посещении соответствующей ноды должен вернуть None; 2. Если в словаре по тому же ключу лежит True, мы берем содержимое блока if и заменяем на него сам if. То есть код из блока if начинает выполняться без условий. Функция, которая выглядит вот так:

```python
def kek():
  print('begin')
  if linux:
    print('its linux')
  if windows:
    print('its windows')
  print('end')
```

... после модификации превратится вот в это:

```python
def new_kek():
  print('begin')
  print('its linux')
  print('end')
```

Практически применить эту штуку можно, к примеру, если мы не хотим постоянно проверять в рантайме некое условие, которое точно известно на момент начала выполнения программы, и которое не должно измениться до конца. Это может быть что-то, извлеченное из конфига, или какой-то платформозависимый кусок кода. Но лучше для таких целей все же использовать какую-нибудь [фабрику](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%B0%D1%8F_%D1%84%D0%B0%D0%B1%D1%80%D0%B8%D0%BA%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)).

## Оптимизация хвостовой рекурсии

[Хвостовая рекурсия](https://ru.wikipedia.org/wiki/%D0%A5%D0%B2%D0%BE%D1%81%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F) - это такая рекурсия, где функция возвращает результат вызова самой себя непосредственно в блоке return. Многие компиляторы других языков программирования умеют автоматически оптимизировать хвостовую рекурсию, превращая ее алгоритм в итеративный. Но в CPython такой оптимизации нет by design, по причинам, которые [перечислил](http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html) сам Гвидо ван Россум. Спорить с Гвидо мы не будем, его причины отказа от оптимизации вполне весомые, но все же развлечения ради напишем свой оптимизатор. К сожалению, у нас не получится сделать это так же бесшовно, как эта функциональность могла бы выглядеть, будучи встроенной непосредственно в интерпретатор.
