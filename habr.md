# "Оптимизируем" функции на уровне AST

Python предоставляет программисту огромное пространство свободы. Увы, обычно это довольно дорогая в плане производительности свобода, зато при правильном применении иногда она позволяет творить сущую магию. Но сегодня мы поговорим не о таких вот, "богоугодных", применениях свободы, а о том, что в прикладном программировании не стоит использовать никогда - о модификациях кода на уровне AST.

## Да кто такой этот ваш AST?

Обычно принято говорить, что [CPython](https://en.wikipedia.org/wiki/CPython) выполняет код построчно. Это не совсем правда, и прежде, чем идти дальше, я должен сделать небольшую паузу, чтобы кратко описать схему его работы.

Прежде всего, любой код - это последовательность символов в некоем файле (в случае [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) - введенная в консоли). Как бы по-программистски эта последовательность ни выглядела, она не является программой, то есть не может быть выполнена компьютером, пока с ней не будет проделан ряд шагов.

Первый шаг - [парсинг текста](https://en.wikipedia.org/wiki/Parsing). Если мы представим парсер как функцию, то на вход она должна получать "сырой" текст, а на выходе давать уже последовательность неких "токенов", то есть значащих элементов нашей программы. Токенами могут быть различные "захардкоженные" (for, if, True и т. д.) ключевые слова программы, имена сущностей (переменных, функций, классов), строковые литералы и прочее. Парсинг происходит по некоторому набору правил, называемому [абстрактной грамматикой](https://docs.python.org/3.2/library/ast.html#abstract-grammar). Конкретно в случае CPython мы не имеем возможности, к сожалению, как-то влезть в процесс парсинга, добавив таким образом, скажем, новый набор ключевых слов.

Второй шаг - построение на основе полученных из предыдущего шага токенов синтаксического дерева (или, как его принято называть у нас в деревне - [AST](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)). AST - это, как очевидно по названию, некая [древовидная](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2)) структура данных, где каждая ноды получена из какого-нибудь токена, который мы извлекли на этапе парсинга. Эта нода может быть терминальной, либо содержащей ссылки на нижележащие ноды. Скажем, нода, представляющая блок условия, может содержать с себе список нод, описывающих действия программы в случае, когда это условие выполняется. Ноды в AST являются типизированными, то есть они имеют разный набор свойств, когда представляют разные виды токенов.

Третий шаг - генерация на основе AST графа потока управления ([Control Flow Graf](https://en.wikipedia.org/wiki/Control-flow_graph)). Очень грубо выражаясь, это такая "поумневшая" форма нашего AST. Именно на данном этапе уже становится понятно, что лежит в наших переменных, и какой код исполняется в каком порядке.

Четвертый и пятый шаги - компиляция графа в [байт-код](https://en.wikipedia.org/wiki/Bytecode) и его выполнение на [виртуальной машине](https://habr.com/ru/post/501338/). Тут наши полномочия все, код вступает в законную силу и изменению не подлежит (на самом деле подлежит, но надо упороться чуть [посильнее](https://docs.python.org/3/library/dis.html)).

Именно на втором шаге мы будем проводить свои "оптимизации" (я не случайно беру это слово в кавычки, но почему - раскрою позже). По сути они сводятся к трем типам возможных действий: добавление, удаление нод или модификация уже существующих (скажем, подмена одного строкового литерала другим). Работа с синтаксическим деревом является с одной стороны достаточно простым, с другой - очень мощным средством, позволяющим писать программы, которые буквально переписывают свой исходный код на лету (на самом деле нет, но выглядит это как будто бы так).

Что очень важно понимать про AST - оно "глупое". Оно не знает, что на самом деле лежит в ваших переменных - это определяется во время выполнения. По сути все, что оно из себя представляет - это некая чуть более упорядоченная форма бытия того самого текстового файлика, что вы подали на вход программы.

## Минздрав предупреждает

"не должен находиться у тебя [...] волшебник [...] ибо мерзок пред Господом всякий, делающий это, и за сии‐то мерзости Господь, Бог твой, изгоняет их от лица твоего" ([Второзаконие](https://bibleonline.ru/bible/rst66/deu-18/) 18:10-12)

Все эти наши штуки с AST интересные и вроде бы кажутся даже полезными, но не стоит поддаваться искушению применять такую магию в мире маглов. Здесь я опишу только общие соображения, почему это так, но дальше вы можете увидеть и другие проблемы с каждой из предложенных модификаций.

1. Фактически выполняться будет не тот код, что вы видите в файле с программой. У программистов пухнут головы уже от работы с тем кодом, что они видят, а тут, представьте, уже написанный код начинает себя вести не так, как выглядит.

2. Вы должны держать в голове нюансы реализации конкретной "оптимизации" и учитывать возможные побочные эффекты. Это вместо того, чтобы получше сосредоточиться на том, что должна делать ваша программа.

3. Средства интроспекции Python начинают врать. Допустим, мы добавили несколько нод в AST. Эти ноды не привязаны к конкретным строчкам исходного файла с кодом. А теперь вспомните, как выглядит, скажем, трейсбэк, когда в коде происходят исключения. Там подробно указывается, в какой строчке кода и с какой операцией произошла ошибка. Если эта ошибка случится в при выполнении кода из этих новых нод, трейсбек вас просто обманет.

4. Реальная выгода от большинства модификаций обычно крайне мала. Да, вам может показаться хорошей идеей применить такие модификации, как, скажем, раскрытие циклов или инлайнинг функций. Но увы, как показала практика, реальное ускорение кода при этом обычно находится на грани погрешности измерений. Если вам не хватает скорости в программах, написанных на Python, обычно самое лучшее решение - переписать их на чем-то еще.

## Общий воркфлоу
